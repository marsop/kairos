@page "/history"
@using Budgetr.Shared.Services
@using Budgetr.Shared.Models
@using Budgetr.Shared.Resources
@inject ITimeTrackingService TimeService
@inject IStringLocalizer<Strings> Localizer
@implements IDisposable

<div class="history-page">
    <h1 class="page-title">@Localizer["NavHistory"]</h1>
    
    @if (!Events.Any())
    {
        <div class="empty-state">
            <span class="empty-icon">ðŸ“­</span>
            <p>@Localizer["NoEvents"]</p>
            <p class="empty-hint">@Localizer["StartMeterHint"]</p>
        </div>
    }
    else
    {
        <div class="events-list">
            @foreach (var evt in Events)
            {
                <div class="event-card @(evt.Factor >= 0 ? "positive" : "negative") @(evt.IsActive ? "active" : "")">
                    <div class="event-header">
                        <span class="event-meter-name">@evt.MeterName</span>
                        <div class="event-header-actions">
                            @if (evt.IsActive)
                            {
                                <span class="event-badge active-badge">
                                    <span class="pulse"></span>
                                    @Localizer["Active"]
                                </span>
                            }
                            @if (!evt.IsActive)
                            {
                                <button class="edit-btn" @onclick="() => StartEditEvent(evt)" title="@Localizer["EditTimes"]">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                        <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
                                        <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
                                    </svg>
                                </button>
                                <button class="delete-btn" @onclick="() => ConfirmDelete(evt)" title="@Localizer["DeleteMeter"]">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                        <polyline points="3 6 5 6 21 6"></polyline>
                                        <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                                        <line x1="10" y1="11" x2="10" y2="17"></line>
                                        <line x1="14" y1="11" x2="14" y2="17"></line>
                                    </svg>
                                </button>
                            }
                        </div>
                    </div>
                    
                    <div class="event-times">
                        <div class="event-time">
                            <span class="time-label">@Localizer["Started"]</span>
                            <span class="time-value">@FormatDateTime(evt.StartTime)</span>
                        </div>
                        @if (evt.EndTime.HasValue)
                        {
                            <div class="event-time">
                                <span class="time-label">@Localizer["Ended"]</span>
                                <span class="time-value">@FormatDateTime(evt.EndTime.Value)</span>
                            </div>
                        }
                    </div>
                    
                    <div class="event-stats">
                        <div class="event-stat">
                            <span class="stat-label">@Localizer["Duration"]</span>
                            <span class="stat-value">@FormatDuration(evt.Duration)</span>
                        </div>
                        <div class="event-stat">
                            <span class="stat-label">@Localizer["Contribution"]</span>
                            <span class="stat-value contribution @(evt.TimeContribution.TotalHours >= 0 ? "positive" : "negative")">
                                @FormatContribution(evt.TimeContribution)
                            </span>
                        </div>
                    </div>
                </div>
            }
        </div>
    }
</div>

@if (_eventToDelete != null)
{
    <div class="modal-overlay" @onclick="CancelDelete">
        <div class="modal-dialog" @onclick:stopPropagation="true">
            <h3>@Localizer["DeleteEntryTitle"]</h3>
            <p>@Localizer["DeleteEntryConfirm", _eventToDelete.MeterName]</p>
            <p class="modal-contribution">@Localizer["DeleteEntryWarning", FormatContribution(_eventToDelete.TimeContribution)]</p>
            <div class="modal-actions">
                <button class="btn-cancel" @onclick="CancelDelete">@Localizer["Cancel"]</button>
                <button class="btn-delete" @onclick="DeleteEvent">@Localizer["Delete"]</button>
            </div>
        </div>
    </div>
}

@if (_eventToEdit != null)
{
    <div class="modal-overlay" @onclick="CancelEdit">
        <div class="modal-dialog" @onclick:stopPropagation="true">
            <h3>@Localizer["EditTimesTitle"]</h3>
            <div class="edit-form">
                <div class="edit-field">
                    <label class="edit-label">@Localizer["StartTime"]</label>
                    <input type="datetime-local" class="edit-input" 
                           value="@_editStartTime.ToString("yyyy-MM-ddTHH:mm")" 
                           @onchange="OnStartTimeChanged" />
                </div>
                <div class="edit-field">
                    <label class="edit-label">@Localizer["EndTime"]</label>
                    <input type="datetime-local" class="edit-input" 
                           value="@_editEndTime.ToString("yyyy-MM-ddTHH:mm")" 
                           @onchange="OnEndTimeChanged" />
                </div>
                @if (!string.IsNullOrEmpty(_editError))
                {
                    <p class="edit-error">@_editError</p>
                }
            </div>
            <div class="modal-actions">
                <button class="btn-cancel" @onclick="CancelEdit">@Localizer["Cancel"]</button>
                <button class="btn-save" @onclick="SaveEditEvent">@Localizer["Save"]</button>
            </div>
        </div>
    </div>
}

@code {
    private IEnumerable<MeterEvent> Events => TimeService.Account.Events
        .OrderByDescending(e => e.StartTime);
    
    private System.Threading.Timer? _timer;
    private MeterEvent? _eventToDelete;
    private MeterEvent? _eventToEdit;
    private DateTime _editStartTime;
    private DateTime _editEndTime;
    private string? _editError;

    protected override void OnInitialized()
    {
        TimeService.OnStateChanged += StateHasChanged;
        
        // Update every second when a meter is active
        _timer = new System.Threading.Timer(_ =>
        {
            if (TimeService.GetActiveEvent() != null)
            {
                InvokeAsync(StateHasChanged);
            }
        }, null, TimeSpan.Zero, TimeSpan.FromSeconds(1));
    }

    private string FormatDateTime(DateTimeOffset dateTime)
    {
        var local = dateTime.ToLocalTime();
        var now = DateTimeOffset.Now;
        
        if (local.Date == now.Date)
        {
            return Localizer["TodayAt", local.ToString("HH:mm")];
        }
        else if (local.Date == now.Date.AddDays(-1))
        {
            return Localizer["YesterdayAt", local.ToString("HH:mm")];
        }
        else
        {
            return Localizer["DateTimeAt", local.ToString("MMM d"), local.ToString("HH:mm")];
        }
    }

    private string FormatDuration(TimeSpan duration)
    {
        if (duration.TotalHours >= 1)
        {
            return Localizer["DurationLong", (int)duration.TotalHours, duration.Minutes];
        }
        else if (duration.TotalMinutes >= 1)
        {
            return Localizer["DurationShort", (int)duration.TotalMinutes, duration.Seconds];
        }
        else
        {
            return Localizer["DurationSeconds", (int)duration.TotalSeconds];
        }
    }

    private string FormatContribution(TimeSpan contribution)
    {
        var sign = contribution.TotalHours >= 0 ? "+" : "";
        var hours = contribution.TotalHours;
        
        if (Math.Abs(hours) >= 1)
        {
            return $"{sign}{hours:F2}h";
        }
        else
        {
            var minutes = contribution.TotalMinutes;
            return $"{sign}{minutes:F1}m";
        }
    }

    private void ConfirmDelete(MeterEvent evt)
    {
        _eventToDelete = evt;
    }

    private void CancelDelete()
    {
        _eventToDelete = null;
    }

    private void DeleteEvent()
    {
        if (_eventToDelete != null)
        {
            TimeService.DeleteEvent(_eventToDelete.Id);
            _eventToDelete = null;
        }
    }

    private void StartEditEvent(MeterEvent evt)
    {
        _eventToEdit = evt;
        _editStartTime = evt.StartTime.ToLocalTime().DateTime;
        _editEndTime = evt.EndTime!.Value.ToLocalTime().DateTime;
        _editError = null;
    }

    private void CancelEdit()
    {
        _eventToEdit = null;
        _editError = null;
    }

    private void OnStartTimeChanged(ChangeEventArgs e)
    {
        if (DateTime.TryParse(e.Value?.ToString(), out var dt))
        {
            _editStartTime = dt;
        }
    }

    private void OnEndTimeChanged(ChangeEventArgs e)
    {
        if (DateTime.TryParse(e.Value?.ToString(), out var dt))
        {
            _editEndTime = dt;
        }
    }

    private void SaveEditEvent()
    {
        if (_eventToEdit == null) return;

        _editError = null;

        var newStart = new DateTimeOffset(_editStartTime, DateTimeOffset.Now.Offset);
        var newEnd = new DateTimeOffset(_editEndTime, DateTimeOffset.Now.Offset);

        if (newStart >= newEnd)
        {
            _editError = Localizer["EndBeforeStart"];
            return;
        }

        if (newEnd > DateTimeOffset.Now)
        {
            _editError = Localizer["FutureEndTime"];
            return;
        }

        try
        {
            TimeService.UpdateEventTimes(_eventToEdit.Id, newStart.ToUniversalTime(), newEnd.ToUniversalTime());
            _eventToEdit = null;
        }
        catch (Exception ex)
        {
            _editError = ex.Message;
        }
    }

    public void Dispose()
    {
        TimeService.OnStateChanged -= StateHasChanged;
        _timer?.Dispose();
    }
}
